package com.wang.code.designPatterns;


/*

设计模式：即Design Patterns，是指在java软件设计中被反复使用的一种代码设计经验。
        使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。

设计模式主要是基于OOP编程提炼的，它基于以下几个原则：
    开闭原则---------对拓展开放，对修改关闭
    里氏代换原则------返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方
    依赖倒转原则------针对接口编程，依赖于抽象而不依赖于具体
    接口隔离原则------使用多个隔离的接口，比使用单个接口要好
    迪米特法则--------一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
    合成复用原则------尽量使用合成/聚合的方式，而不是使用继承。

uml类图的六种类与类之间的关系
    见本package下的  umlImage.png

在java中，设计模式共有23种

可以被归纳为三个大类：


    工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。
    桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。
    策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。

    一、创建型模式：创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。

        1、工厂方法: 工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道。
        2、抽象工厂: 定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂与抽象产品打交道。
        3、生成器: Builder模式是为了创建一个复杂的对象，需要多个步骤完成创建，或者需要多个零件组装的场景，且创建过程中可以灵活调用不同的步骤或组件。
        4、原型: clone、copy...原型模式是根据一个现有对象实例复制出一个新的实例，复制出的类型和属性与原实例相同。
        5、单例: Singleton模式是为了保证一个程序的运行期间，某个类有且只有一个全局唯一实例；
            实现方式：
                a. 懒汉式         最基础的getInstance， 使用时创建，延迟加载，
                    if (instance == null){
                        instance = new Lanhan();
                        return instance;
                    }
                b. 恶汉式         类加载时创建静态变量
                    public static final Singleton instance = new Singleton();
                c. DCL双检锁      synchronized + volatile
                    private volatile static Instance ins = null;
                    public static Instance getInstance(){
                        if (ins == null){
                            synchronized (Instance.class){
                                if (ins == null){
                                    ins = new Instance();
                                }
                            }
                        }
                        return ins;
                    }
                d. 静态内部类      静态内部，这种方式比较好，同样是延迟加载
                    public class Singleton{
                        private static class SingletonHolder {
                            private static final Singleton Instance = new Singleton();
                        }

                        private Singleton();

                        public static final Singleton getInstance{
                            return SingletonHolder.Instance;
                        }
                    }
                e. 枚举           java保证枚举类的实例的唯一性

    二、结构型模式：主要涉及如何组合各种对象以便获得更好、更灵活的结构

        6、适配器: Adapter模式可以将一个A接口转换为B接口，使得新的对象符合B接口规范。
        7、桥接: 桥接模式通过分离一个抽象接口和它的实现部分，使得设计可以按两个维度独立扩展. 使用组合的方式而不是子类，防止子类爆炸💥
        8、组合: Composite模式使得叶子对象和容器对象具有一致性，从而形成统一的树形结构，并用一致的方式去处理它们。
        9、装饰器: 可以在运行期动态地给核心功能增加任意个附加功能。
        10、外观(门面): Facade模式是为了给客户端提供一个统一入口，并对外屏蔽内部子系统的调用细节。
        11、享元: 享元模式的设计思想是尽量复用已创建的对象，常用于工厂方法内部的优化。
        12、代理: 代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。

    三、行为型模式: 行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。

        13、责任链: 责任链模式是一种把多个处理器组合在一起，依次处理请求的模式
        14、命令: 命令模式的设计思想是把命令的创建和执行分离，使得调用者无需关心具体的执行过程,通过封装Command对象，命令模式可以保存已执行的命令，从而支持撤销、重做等操作。
        15、解释器: 解释器模式通过抽象语法树实现对用户输入的解释执行, 解释器模式的实现通常非常复杂，且一般只能解决一类特定问题。
        16、迭代器: Iterator模式常用于遍历集合，它允许集合提供一个统一的Iterator接口来遍历元素，同时保证调用者对集合内部的数据结构一无所知，从而使得调用者总是以相同的接口遍历各种不同类型的集合。
        17、中介: 中介模式是通过引入一个中介对象，把多边关系变成多个双边关系，从而简化系统组件的交互耦合度。
        18、备忘录: 备忘录模式是为了保存对象的内部状态，并在将来恢复，大多数软件提供的保存、打开，以及编辑过程中的Undo、Redo都是备忘录模式的应用。
        19、观察者: 观察者模式，又称发布-订阅模式，是一种一对多的通知机制，使得双方无需关心对方，只关心通知本身。
        20、状态: 状态模式的设计思想是把不同状态的逻辑分离到不同的状态类中，从而使得增加新状态更容易；状态模式的实现关键在于状态转换。简单的状态转换可以直接由调用方指定，复杂的状态转换可以在内部根据条件触发完成。
        21、策略: 策略模式是为了允许调用方选择一个算法，从而通过不同策略实现不同的计算结果。通过扩展策略，不必修改主逻辑，即可获得新策略的结果。
        22、模版方法: 模板方法是一种高层定义骨架，底层实现细节的设计模式，适用于流程固定，但某些步骤不确定或可替换的情况。
        23、访问者: 访问者模式是为了抽象出作用于一组复杂对象的操作，并且后续可以新增操作而不必对现有的对象结构做任何改动。

*/